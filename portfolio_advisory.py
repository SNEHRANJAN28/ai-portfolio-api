# -*- coding: utf-8 -*-
"""Portfolio Advisory

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gcMY4oldobHzE2inhmtDQOyGQA1ejVoW
"""

"""
Interactive Portfolio Advisory Model
------------------------------------
Asks user for:
1. Investment amount
2. Time horizon (years)
3. Risk tolerance (low / medium / high)
4. Investment goal (growth / income / preservation)

Then computes:
 - Risk score
 - Forecasted returns for assets
 - Optimal portfolio using Modern Portfolio Theory
 - Explanation + educational tips
"""

from dataclasses import dataclass
from typing import Dict, Optional
import numpy as np
import pandas as pd
import math
from scipy.optimize import minimize

# ---------------------------
# Data Structures
# ---------------------------
@dataclass
class UserInput:
    amount: float
    risk_tolerance: str
    investment_horizon: int
    goal: str


@dataclass
class RiskProfile:
    risk_score: float
    investment_goal: str


@dataclass
class Forecast:
    expected_return: float
    volatility: float


@dataclass
class PortfolioResult:
    weights: Dict[str, float]
    allocations: Dict[str, float]
    expected_portfolio_return: float
    expected_portfolio_volatility: float
    explanation: str
    tips: str


# ---------------------------
# Portfolio Advisor Class
# ---------------------------
class PortfolioAdvisor:
    def __init__(self):
        self.assets = ["Stocks", "Mutual Funds", "FD", "Crypto"]
        self.asset_type = {"Stocks": "volatile", "Mutual Funds": "stable",
                           "FD": "stable", "Crypto": "volatile"}
        self.rng = np.random.default_rng(42)

    # ---------------------------
    # User Input Layer
    # ---------------------------
    def get_user_input(self) -> UserInput:
        print("ðŸ’¬ Let's build your portfolio.\nPlease answer the following questions:\n")
        amount = float(input("1ï¸âƒ£ What is your investment amount (â‚¹)? : "))
        horizon = int(input("2ï¸âƒ£ For how many years do you plan to invest? : "))
        risk = input("3ï¸âƒ£ What is your risk tolerance? (low / medium / high): ").strip().lower()
        goal = input("4ï¸âƒ£ What is your investment goal? (growth / income / preservation): ").strip().lower()

        print("\nâœ… Got it! Building your personalized portfolio...\n")
        return UserInput(amount, risk, horizon, goal)

    # ---------------------------
    # Risk Profiling Layer
    # ---------------------------
    def compute_risk_score(self, user: UserInput) -> RiskProfile:
        base_map = {"low": 0.25, "medium": 0.55, "high": 0.8}
        base = base_map.get(user.risk_tolerance, 0.55)
        horizon_adj = min(0.15, max(-0.1, (user.investment_horizon - 3) * 0.03))
        score = max(0.0, min(1.0, base + horizon_adj))
        return RiskProfile(risk_score=round(score, 2), investment_goal=user.goal)

    # ---------------------------
    # Forecasting Layer (simplified)
    # ---------------------------
    def forecast_assets(self, user: UserInput) -> Dict[str, Forecast]:
        forecasts = {
            "Stocks": Forecast(0.12, 0.18),
            "Mutual Funds": Forecast(0.09, 0.10),
            "FD": Forecast(0.06, 0.01),
            "Crypto": Forecast(0.15, 0.25),
        }
        return forecasts

    # ---------------------------
    # Portfolio Optimization Layer (MPT)
    # ---------------------------
    def optimize_portfolio(self, forecasts: Dict[str, Forecast], risk_score: float) -> Dict[str, float]:
        mu = np.array([f.expected_return for f in forecasts.values()])
        sigma = np.array([f.volatility for f in forecasts.values()])

        # Covariance matrix (simplified)
        cov = np.diag(sigma ** 2 * 0.8)
        cov += 0.2 * np.outer(sigma, sigma)

        gamma = 1 + risk_score * 9  # higher score => higher risk appetite

        def objective(w):
            return w @ cov @ w - gamma * (mu @ w)

        cons = {"type": "eq", "fun": lambda w: np.sum(w) - 1}
        bounds = [(0, 1)] * len(mu)
        x0 = np.repeat(1 / len(mu), len(mu))
        result = minimize(objective, x0, bounds=bounds, constraints=cons)

        weights = result.x / result.x.sum()
        return {asset: round(float(w), 3) for asset, w in zip(self.assets, weights)}

    # ---------------------------
    # Explainability Layer
    # ---------------------------
    def generate_explanation(self, risk_profile: RiskProfile, weights: Dict[str, float]) -> str:
        main_allocs = sorted(weights.items(), key=lambda x: x[1], reverse=True)
        summary = ", ".join([f"{int(w * 100)}% {a}" for a, w in main_allocs])
        return (f"Since your risk level is {risk_profile.investment_goal} (score {risk_profile.risk_score}), "
                f"Iâ€™ve chosen a portfolio with {summary}. "
                f"This mix balances risk and return according to your {risk_profile.investment_goal} goal.")

    def generate_tips(self, forecasts: Dict[str, Forecast]) -> str:
        mf = forecasts["Mutual Funds"].expected_return * 100
        return (f"ðŸ’¡ Mutual funds diversify your risk. "
                f"Over time, your expected annual return could be around {mf:.1f}%. "
                "Rebalance annually and avoid emotional trading.")

    # ---------------------------
    # Pipeline Runner
    # ---------------------------
    def run(self):
        user = self.get_user_input()
        risk_profile = self.compute_risk_score(user)
        forecasts = self.forecast_assets(user)
        weights = self.optimize_portfolio(forecasts, risk_profile.risk_score)

        allocations = {a: round(w * user.amount, 2) for a, w in weights.items()}
        mu = np.array([forecasts[a].expected_return for a in self.assets])
        cov = np.diag([forecasts[a].volatility for a in self.assets])
        w = np.array(list(weights.values()))

        port_return = round(float(np.dot(mu, w)), 4)
        port_vol = round(float(np.sqrt(np.dot(w, w * np.diag(cov)))), 4)

        explanation = self.generate_explanation(risk_profile, weights)
        tips = self.generate_tips(forecasts)

        print("=== ðŸ“Š Optimal Portfolio ===")
        for a in self.assets:
            print(f"{a:12s}: {weights[a]*100:5.1f}%  -> â‚¹{allocations[a]:,.2f}")
        print(f"\nExpected Annual Return: {port_return*100:.2f}%")
        print(f"Expected Annual Volatility: {port_vol*100:.2f}%\n")
        print("ðŸ§  Explanation:")
        print(explanation)
        print("\nðŸ’¬ Tips:")
        print(tips)


# ---------------------------
# Run the Model
# ---------------------------
if __name__ == "__main__":
    advisor = PortfolioAdvisor()
    advisor.run()

"""#Portfolio Advisory

"""

# ================================================================
# ðŸ’°  AI Portfolio Advisory System â€” Full Google Colab Version  ðŸ’°
# Modular Architecture + Explainability Layer + Interactive CLI
# ================================================================

from typing import Dict, List, Optional, Tuple, Any
import numpy as np
import pandas as pd

# Optional imports (safe fallbacks if unavailable)
try:
    from statsmodels.tsa.arima.model import ARIMA
except Exception:
    ARIMA = None

try:
    from sklearn.linear_model import LinearRegression
    from sklearn.preprocessing import StandardScaler
except Exception:
    LinearRegression = None
    StandardScaler = None

try:
    import scipy.optimize as sco
except Exception:
    sco = None

try:
    import tensorflow as tf
    from tensorflow.keras import layers, models
except Exception:
    tf = None
    layers = None
    models = None


# -----------------------------
# Risk Profiler
# -----------------------------
class RiskProfiler:
    RISK_TOLERANCE_MAP = {"low": 0.2, "medium": 0.5, "high": 0.8}

    def __init__(self, weight_risk_pref=0.6, weight_horizon=0.3, weight_s2i=0.1):
        self.w_risk = weight_risk_pref
        self.w_horizon = weight_horizon
        self.w_s2i = weight_s2i

    def score(self, risk_tolerance, horizon_years, savings_to_income=None):
        rt_val = self.RISK_TOLERANCE_MAP.get(risk_tolerance.lower(), 0.5)
        horizon_score = np.clip(horizon_years / 30.0, 0.0, 1.0)
        s2i_score = np.clip(savings_to_income or 0.2, 0.0, 1.0)
        raw = self.w_risk * rt_val + self.w_horizon * horizon_score + self.w_s2i * s2i_score
        return float(np.clip(raw, 0.0, 1.0))


# -----------------------------
# Sentiment Analyzer (stub)
# -----------------------------
class SentimentAnalyzer:
    def __init__(self, model_name=None):
        self.model_name = model_name or "finbert-stub"

    def score_texts(self, texts):
        if len(texts) == 0:
            return []
        rng = np.random.RandomState(42)
        return list(rng.uniform(-0.2, 0.2, size=len(texts)))


# -----------------------------
# Market Forecaster
# -----------------------------
class MarketForecaster:
    def __init__(self):
        self.scaler = StandardScaler() if StandardScaler is not None else None

    @staticmethod
    def _annualize_returns(daily_returns, periods_per_year=252):
        mean_daily = np.nanmean(daily_returns)
        vol_daily = np.nanstd(daily_returns, ddof=1)
        mean_ann = (1 + mean_daily) ** periods_per_year - 1
        vol_ann = vol_daily * np.sqrt(periods_per_year)
        return float(mean_ann), float(vol_ann)

    def forecast_arima(self, asset_series, steps=252):
        if asset_series.dropna().shape[0] < 10 or ARIMA is None:
            returns = asset_series.pct_change().dropna().values
            return self._annualize_returns(returns)
        try:
            y = np.log(asset_series.dropna())
            model = ARIMA(y, order=(1, 1, 0))
            fitted = model.fit()
            forecast_log = fitted.forecast(steps=steps)
            daily_forecast_returns = np.diff(forecast_log) / forecast_log[:-1]
            return self._annualize_returns(daily_forecast_returns)
        except Exception:
            returns = asset_series.pct_change().dropna().values
            return self._annualize_returns(returns)

    def forecast_lstm(self, asset_series, n_past=60, n_future=21, epochs=5, batch_size=16):
        returns = asset_series.pct_change().dropna()
        if tf is None or len(returns) < n_past + 10:
            return self._annualize_returns(returns.values)
        try:
            data = returns.values.reshape(-1, 1)
            scaler = self.scaler or StandardScaler()
            data_scaled = scaler.fit_transform(data)

            X, y = [], []
            for i in range(n_past, len(data_scaled)):
                X.append(data_scaled[i - n_past:i, 0])
                y.append(data_scaled[i, 0])
            X = np.array(X)
            y = np.array(y)
            X = X.reshape((X.shape[0], X.shape[1], 1))

            model = models.Sequential([
                layers.Input(shape=(X.shape[1], 1)),
                layers.LSTM(16, activation="tanh"),
                layers.Dense(1)
            ])
            model.compile(optimizer="adam", loss="mse")
            model.fit(X, y, epochs=epochs, batch_size=batch_size, verbose=0)

            seq = data_scaled[-n_past:].reshape(1, n_past, 1)
            preds = []
            for _ in range(n_future):
                p = model.predict(seq, verbose=0)[0, 0]
                preds.append(p)
                seq = np.roll(seq, -1, axis=1)
                seq[0, -1, 0] = p
            preds = scaler.inverse_transform(np.array(preds).reshape(-1, 1)).flatten()
            return self._annualize_returns(preds)
        except Exception:
            return self._annualize_returns(returns.values)

    def batch_forecast(self, price_df, method_map=None):
        results = {}
        for col in price_df.columns:
            series = price_df[col].dropna()
            method = (method_map or {}).get(col, "lstm" if series.pct_change().std() > 0.03 else "arima")
            if method == "arima":
                exp_r, vol = self.forecast_arima(series)
            elif method == "lstm":
                exp_r, vol = self.forecast_lstm(series)
            else:
                exp_r, vol = self._annualize_returns(series.pct_change().dropna().values)
            results[col] = {"expected_return": exp_r, "volatility": vol}
        return results


# -----------------------------
# Portfolio Optimizer (MPT)
# -----------------------------
class PortfolioOptimizer:
    def __init__(self, risk_free_rate=0.06):
        self.rf = risk_free_rate

    def maximize_sharpe(self, expected_returns, cov, bounds=None):
        if sco is None:
            raise RuntimeError("scipy is required for optimization")
        n = len(expected_returns)
        if bounds is None:
            bounds = tuple((0.0, 1.0) for _ in range(n))

        def portfolio_perf(w):
            ret = np.dot(w, expected_returns)
            vol = np.sqrt(w.T @ cov @ w)
            sharpe = (ret - self.rf) / vol if vol > 0 else 0
            return ret, vol, sharpe

        def neg_sharpe(w):
            return -portfolio_perf(w)[2]

        cons = ({'type': 'eq', 'fun': lambda w: np.sum(w) - 1},)
        x0 = np.ones(n) / n
        opt = sco.minimize(neg_sharpe, x0, bounds=bounds, constraints=cons, method="SLSQP")
        w = np.clip(opt.x, 0, 1)
        ret, vol, sharpe = portfolio_perf(w)
        return {"weights": w, "return": ret, "volatility": vol, "sharpe": sharpe}


# -----------------------------
# Explainability Engine
# -----------------------------
class ExplainabilityEngine:
    @staticmethod
    def explain(user_input, portfolio_metrics, allocations):
        risk = user_input["risk_tolerance"].capitalize()
        goal = user_input["goal"].capitalize()
        risk_score = portfolio_metrics["risk_score"]
        sharpe = portfolio_metrics["sharpe"]

        # Base rationale
        reasoning = f"Based on your **{risk.lower()} risk tolerance** and a goal of **{goal.lower()}**, "
        if risk_score < 0.4:
            reasoning += "the system prioritized stability and lower volatility assets like Fixed Deposits and Mutual Funds. "
        elif risk_score < 0.7:
            reasoning += "the portfolio strikes a balance between safety and growth by mixing Mutual Funds and Stocks. "
        else:
            reasoning += "the system leaned towards higher-return assets like Stocks and Crypto to maximize growth potential. "

        # Sharpe interpretation
        if sharpe > 1.0:
            sharpe_text = "This indicates strong risk-adjusted performance."
        elif sharpe > 0.5:
            sharpe_text = "This indicates moderate but acceptable risk-adjusted performance."
        else:
            sharpe_text = "This suggests the portfolio takes relatively high risk for its reward."

        # Key allocations
        top_allocs = sorted(allocations, key=lambda x: x["percent"], reverse=True)[:2]
        key_assets = ", ".join([a["asset"] for a in top_allocs])

        return (
            reasoning
            + f"Top allocations were made to **{key_assets}**, "
            + f"driven by their predicted returns and market sentiment. "
            + sharpe_text
        )


# -----------------------------
# Advisory Pipeline
# -----------------------------
class AdvisoryPipeline:
    def __init__(self):
        self.profiler = RiskProfiler()
        self.sentiment = SentimentAnalyzer()
        self.forecaster = MarketForecaster()
        self.optimizer = PortfolioOptimizer()
        self.explainer = ExplainabilityEngine()

    def run(self, user_input, price_df, news_texts=None, amount=10000):
        # Risk score
        risk_score = self.profiler.score(
            user_input.get("risk_tolerance", "medium"),
            user_input.get("investment_horizon", 3),
            user_input.get("savings_to_income", None)
        )

        # Sentiment
        sentiment_signals = {}
        if news_texts:
            for asset, texts in news_texts.items():
                sentiment_signals[asset] = np.mean(self.sentiment.score_texts(texts)) if texts else 0.0

        # Forecasting
        forecasts = self.forecaster.batch_forecast(price_df)
        combined = {}
        for a, f in forecasts.items():
            adj = f["expected_return"] + 0.5 * sentiment_signals.get(a, 0)
            combined[a] = {"expected_return": adj, "volatility": f["volatility"]}

        tickers = list(price_df.columns)
        returns_df = price_df.pct_change().dropna()
        cov = returns_df.cov().values
        exp_vec = np.array([combined[t]["expected_return"] for t in tickers])

        bounds = [(0, 0.6 if risk_score > 0.6 else 0.4 + 0.2 * risk_score)] * len(tickers)
        opt_res = self.optimizer.maximize_sharpe(exp_vec, cov, bounds=bounds)

        allocations = []
        for t, w in zip(tickers, opt_res["weights"]):
            allocations.append({
                "asset": t,
                "percent": float(w) * 100,
                "amount": float(w) * amount,
                "expected_return": combined[t]["expected_return"],
                "volatility": combined[t]["volatility"]
            })

        portfolio_metrics = {
            "expected_return": opt_res["return"],
            "volatility": opt_res["volatility"],
            "sharpe": opt_res["sharpe"],
            "risk_score": risk_score
        }

        explanation = self.explainer.explain(user_input, portfolio_metrics, allocations)

        return {"portfolio_metrics": portfolio_metrics, "allocations": allocations, "explanation": explanation}


# -----------------------------
# Interactive Section
# -----------------------------
def get_user_input():
    print("ðŸ’° Welcome to the AI Portfolio Advisory System ðŸ’°\n")
    amount = float(input("Enter your investment amount (â‚¹): "))
    horizon = int(input("Enter your investment time horizon (in years): "))
    risk = input("Enter your risk-taking ability (low / medium / high): ").strip().lower()
    goal = input("What is your investment goal? (growth / income / balanced): ").strip().lower()
    return {"amount": amount, "investment_horizon": horizon, "risk_tolerance": risk, "goal": goal}


def generate_sample_data():
    dates = pd.date_range(end=pd.Timestamp.today(), periods=500, freq="B")
    np.random.seed(0)
    return pd.DataFrame({
        "MutualFunds": 100 * np.cumprod(1 + np.random.normal(0.0002, 0.001, len(dates))),
        "Stocks": 50 * np.cumprod(1 + np.random.normal(0.0005, 0.02, len(dates))),
        "FD": 100 * np.cumprod(1 + np.random.normal(0.00005, 0.0001, len(dates))),
        "Crypto": 10 * np.cumprod(1 + np.random.normal(0.001, 0.05, len(dates))),
    }, index=dates)


def main():
    user = get_user_input()
    price_df = generate_sample_data()
    news = {
        "Stocks": ["Market shows optimism"],
        "Crypto": ["Crypto volatility remains high but positive trend"],
        "MutualFunds": ["Steady mutual fund inflows"],
        "FD": ["Stable interest rates on FDs"]
    }

    pipeline = AdvisoryPipeline()
    results = pipeline.run(user, price_df, news_texts=news, amount=user["amount"])

    pm = results["portfolio_metrics"]
    print("\nðŸ§  Risk Score:", round(pm["risk_score"], 2))
    print(f"ðŸ“Š Expected Return: {pm['expected_return']*100:.2f}% | "
          f"Volatility: {pm['volatility']*100:.2f}% | Sharpe: {pm['sharpe']:.2f}")

    print("\nðŸ“ˆ Recommended Allocation:")
    for a in results["allocations"]:
        print(f"  {a['asset']:<12} â†’ {a['percent']:.1f}%  (â‚¹{a['amount']:.0f})")

    print("\nðŸ’¬ Explanation:")
    print(results["explanation"])

    print("\nâœ… Done. Your personalized portfolio has been generated.")


# Run the interactive system
main()

"""API CALL"""

# ================================================================
# ðŸ’° AI Portfolio Advisory System â€” FastAPI Version
# ================================================================

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Dict, List, Optional
import numpy as np
import pandas as pd

# Optional imports (safe fallbacks)
try:
    from statsmodels.tsa.arima.model import ARIMA
except Exception:
    ARIMA = None

try:
    from sklearn.preprocessing import StandardScaler
except Exception:
    StandardScaler = None

try:
    import scipy.optimize as sco
except Exception:
    sco = None


# -----------------------------
# Risk Profiler
# -----------------------------
class RiskProfiler:
    RISK_TOLERANCE_MAP = {"low": 0.2, "medium": 0.5, "high": 0.8}

    def __init__(self, weight_risk_pref=0.6, weight_horizon=0.3, weight_s2i=0.1):
        self.w_risk = weight_risk_pref
        self.w_horizon = weight_horizon
        self.w_s2i = weight_s2i

    def score(self, risk_tolerance, horizon_years, savings_to_income=None):
        rt_val = self.RISK_TOLERANCE_MAP.get(risk_tolerance.lower(), 0.5)
        horizon_score = np.clip(horizon_years / 30.0, 0.0, 1.0)
        s2i_score = np.clip(savings_to_income or 0.2, 0.0, 1.0)
        raw = self.w_risk * rt_val + self.w_horizon * horizon_score + self.w_s2i * s2i_score
        return float(np.clip(raw, 0.0, 1.0))


# -----------------------------
# Sentiment Analyzer (stub)
# -----------------------------
class SentimentAnalyzer:
    def score_texts(self, texts):
        if not texts:
            return []
        rng = np.random.RandomState(42)
        return list(rng.uniform(-0.2, 0.2, size=len(texts)))


# -----------------------------
# Market Forecaster
# -----------------------------
class MarketForecaster:
    def __init__(self):
        self.scaler = StandardScaler() if StandardScaler else None

    @staticmethod
    def _annualize_returns(daily_returns, periods_per_year=252):
        mean_daily = np.nanmean(daily_returns)
        vol_daily = np.nanstd(daily_returns, ddof=1)
        mean_ann = (1 + mean_daily) ** periods_per_year - 1
        vol_ann = vol_daily * np.sqrt(periods_per_year)
        return float(mean_ann), float(vol_ann)

    def forecast_arima(self, asset_series, steps=252):
        if asset_series.dropna().shape[0] < 10 or ARIMA is None:
            returns = asset_series.pct_change().dropna().values
            return self._annualize_returns(returns)
        try:
            y = np.log(asset_series.dropna())
            model = ARIMA(y, order=(1, 1, 0))
            fitted = model.fit()
            forecast_log = fitted.forecast(steps=steps)
            daily_forecast_returns = np.diff(forecast_log) / forecast_log[:-1]
            return self._annualize_returns(daily_forecast_returns)
        except Exception:
            returns = asset_series.pct_change().dropna().values
            return self._annualize_returns(returns)

    def batch_forecast(self, price_df):
        results = {}
        for col in price_df.columns:
            series = price_df[col].dropna()
            exp_r, vol = self.forecast_arima(series)
            results[col] = {"expected_return": exp_r, "volatility": vol}
        return results


# -----------------------------
# Portfolio Optimizer
# -----------------------------
class PortfolioOptimizer:
    def __init__(self, risk_free_rate=0.06):
        self.rf = risk_free_rate

    def maximize_sharpe(self, expected_returns, cov, bounds=None):
        if sco is None:
            raise RuntimeError("scipy is required for optimization")

        n = len(expected_returns)
        if bounds is None:
            bounds = tuple((0.0, 1.0) for _ in range(n))

        def portfolio_perf(w):
            ret = np.dot(w, expected_returns)
            vol = np.sqrt(w.T @ cov @ w)
            sharpe = (ret - self.rf) / vol if vol > 0 else 0
            return ret, vol, sharpe

        def neg_sharpe(w):
            return -portfolio_perf(w)[2]

        cons = ({'type': 'eq', 'fun': lambda w: np.sum(w) - 1},)
        x0 = np.ones(n) / n
        opt = sco.minimize(neg_sharpe, x0, bounds=bounds, constraints=cons, method="SLSQP")
        w = np.clip(opt.x, 0, 1)
        ret, vol, sharpe = portfolio_perf(w)
        return {"weights": w, "return": ret, "volatility": vol, "sharpe": sharpe}


# -----------------------------
# Explainability Engine
# -----------------------------
class ExplainabilityEngine:
    @staticmethod
    def explain(user_input, portfolio_metrics, allocations):
        risk = user_input["risk_tolerance"].capitalize()
        goal = user_input["goal"].capitalize()
        risk_score = portfolio_metrics["risk_score"]
        sharpe = portfolio_metrics["sharpe"]

        reasoning = f"Based on your **{risk.lower()} risk tolerance** and goal of **{goal.lower()}**, "
        if risk_score < 0.4:
            reasoning += "the portfolio focuses on low-volatility assets."
        elif risk_score < 0.7:
            reasoning += "the portfolio balances stability and growth."
        else:
            reasoning += "the portfolio emphasizes high-return assets."

        sharpe_text = (
            "Excellent risk-adjusted performance." if sharpe > 1 else
            "Moderate performance." if sharpe > 0.5 else
            "High risk relative to reward."
        )

        top_allocs = sorted(allocations, key=lambda x: x["percent"], reverse=True)[:2]
        key_assets = ", ".join([a["asset"] for a in top_allocs])
        return f"{reasoning} Key allocations: {key_assets}. {sharpe_text}"


# -----------------------------
# Advisory Pipeline
# -----------------------------
class AdvisoryPipeline:
    def __init__(self):
        self.profiler = RiskProfiler()
        self.sentiment = SentimentAnalyzer()
        self.forecaster = MarketForecaster()
        self.optimizer = PortfolioOptimizer()
        self.explainer = ExplainabilityEngine()

    def run(self, user_input, price_df, news_texts=None, amount=10000):
        risk_score = self.profiler.score(
            user_input.get("risk_tolerance", "medium"),
            user_input.get("investment_horizon", 3),
            user_input.get("savings_to_income", None)
        )

        sentiment_signals = {}
        if news_texts:
            for asset, texts in news_texts.items():
                sentiment_signals[asset] = np.mean(self.sentiment.score_texts(texts)) if texts else 0.0

        forecasts = self.forecaster.batch_forecast(price_df)
        combined = {}
        for a, f in forecasts.items():
            adj = f["expected_return"] + 0.5 * sentiment_signals.get(a, 0)
            combined[a] = {"expected_return": adj, "volatility": f["volatility"]}

        tickers = list(price_df.columns)
        returns_df = price_df.pct_change().dropna()
        cov = returns_df.cov().values
        exp_vec = np.array([combined[t]["expected_return"] for t in tickers])

        bounds = [(0, 0.6 if risk_score > 0.6 else 0.4 + 0.2 * risk_score)] * len(tickers)
        opt_res = self.optimizer.maximize_sharpe(exp_vec, cov, bounds=bounds)

        allocations = []
        for t, w in zip(tickers, opt_res["weights"]):
            allocations.append({
                "asset": t,
                "percent": float(w) * 100,
                "amount": float(w) * amount,
                "expected_return": combined[t]["expected_return"],
                "volatility": combined[t]["volatility"]
            })

        portfolio_metrics = {
            "expected_return": opt_res["return"],
            "volatility": opt_res["volatility"],
            "sharpe": opt_res["sharpe"],
            "risk_score": risk_score
        }

        explanation = self.explainer.explain(user_input, portfolio_metrics, allocations)

        return {"portfolio_metrics": portfolio_metrics, "allocations": allocations, "explanation": explanation}


# -----------------------------
# FastAPI App
# -----------------------------
app = FastAPI(title="AI Portfolio Advisory System")

class UserInput(BaseModel):
    amount: float
    investment_horizon: int
    risk_tolerance: str
    goal: str


@app.get("/")
def root():
    return {"message": "Welcome to the AI Portfolio Advisory System API ðŸš€"}


@app.post("/advise")
def advise(user: UserInput):
    try:
        # Generate synthetic price data
        dates = pd.date_range(end=pd.Timestamp.today(), periods=500, freq="B")
        np.random.seed(0)
        price_df = pd.DataFrame({
            "MutualFunds": 100 * np.cumprod(1 + np.random.normal(0.0002, 0.001, len(dates))),
            "Stocks": 50 * np.cumprod(1 + np.random.normal(0.0005, 0.02, len(dates))),
            "FD": 100 * np.cumprod(1 + np.random.normal(0.00005, 0.0001, len(dates))),
            "Crypto": 10 * np.cumprod(1 + np.random.normal(0.001, 0.05, len(dates))),
        }, index=dates)

        news = {
            "Stocks": ["Market shows optimism"],
            "Crypto": ["Crypto volatility remains high but positive trend"],
            "MutualFunds": ["Steady mutual fund inflows"],
            "FD": ["Stable interest rates on FDs"]
        }

        pipeline = AdvisoryPipeline()
        results = pipeline.run(user.dict(), price_df, news_texts=news, amount=user.amount)
        return results

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))